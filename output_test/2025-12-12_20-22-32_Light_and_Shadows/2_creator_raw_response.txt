{
  "index.html": "<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\"content=\"width=device-width, initial-scale=1.0\">\n    <title>Light and Shadows</title>\n    <style>\n        :root {\n            --bg: #0f172a;\n            --panel: #111827;\n            --accent: #22c55e;\n            --accent2: #3b82f6;\n            --text: #e5e7eb;\n            --muted: #9ca3af;\n            --danger: #ef4444;\n        }\n        * { box-sizing: border-box; }\n        body {\n            margin: 0;\n            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n            background: linear-gradient(180deg, #0b1220, #0f172a);\n            color: var(--text);\n            min-height: 100vh;\n            display: flex;\n            flex-direction: column;\n        }\n        header {\n            padding: 14px 16px;\n            background: rgba(17, 24, 39, 0.8);\n            border-bottom: 1px solid rgba(255,255,255,0.08);\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        header h1 {\n            margin: 0;\n            font-size: 18px;\n            letter-spacing: 0.3px;\n        }\n        header p {\n            margin: 6px 0 0;\n            font-size: 13px;\n            color: var(--muted);\n        }\n        .container {\n            padding: 12px;\n            display: flex;\n            flex-direction: column;\n            gap: 12px;\n            flex: 1;\n        }\n        .canvas-wrap {\n            background: #0b1220;\n            border: 1px solid rgba(255,255,255,0.08);\n            border-radius: 12px;\n            overflow: hidden;\n            position: relative;\n        }\n        canvas {\n            width: 100%;\n            height: 360px;\n            display: block;\n            background: radial-gradient(1200px 600px at 10% 50%, rgba(59,130,246,0.15), transparent 60%),\n                        radial-gradient(1200px 600px at 90% 50%, rgba(34,197,94,0.12), transparent 60%),\n                        #0b1220;\n        }\n        .controls {\n            display: grid;\n            gap: 10px;\n            background: rgba(17, 24, 39, 0.8);\n            border: 1px solid rgba(255,255,255,0.08);\n            border-radius: 12px;\n            padding: 12px;\n        }\n        .row {\n            display: grid;\n            grid-template-columns: 1fr;\n            gap: 10px;\n        }\n        .row-2 {\n            display: grid;\n            grid-template-columns: 1fr 1fr;\n            gap: 10px;\n        }\n        label {\n            font-size: 13px;\n            color: var(--muted);\n            display: block;\n            margin-bottom: 6px;\n        }\n        select, button, .toggle {\n            width: 100%;\n            padding: 10px 12px;\n            border-radius: 10px;\n            border: 1px solid rgba(255,255,255,0.12);\n            background: #0f172a;\n            color: var(--text);\n            font-size: 14px;\n            outline: none;\n        }\n        button {\n            cursor: pointer;\n            user-select: none;\n            touch-action: manipulation;\n            min-height: 44px;\n        }\n        .btn-accent {\n            background: linear-gradient(180deg, #22c55e, #16a34a);\n            border: none;\n            color: #052e16;\n            font-weight: 700;\n        }\n        .btn-outline {\n            background: transparent;\n            border: 1px solid rgba(255,255,255,0.18);\n        }\n        .btn-danger {\n            background: linear-gradient(180deg, #ef4444, #dc2626);\n            border: none;\n            color: #2a0707;\n            font-weight: 700;\n        }\n        .btn-group {\n            display: grid;\n            grid-template-columns: repeat(3, 1fr);\n            gap: 8px;\n        }\n        .toggle {\n            display: flex;\n            align-items: center;\n            justify-content: space-between;\n            cursor: pointer;\n            min-height: 44px;\n        }\n        .toggle .pill {\n            display: inline-flex;\n            align-items: center;\n            gap: 8px;\n            padding: 6px 10px;\n            border-radius: 999px;\n            background: rgba(255,255,255,0.08);\n            font-size: 12px;\n            color: var(--muted);\n        }\n        .info {\n            background: rgba(17, 24, 39, 0.8);\n            border: 1px solid rgba(255,255,255,0.08);\n            border-radius: 12px;\n            padding: 12px;\n        }\n        .info p {\n            margin: 0;\n            font-size: 14px;\n            line-height: 1.4;\n        }\n        .footer {\n            display: flex;\n            gap: 10px;\n            align-items: center;\n            justify-content: space-between;\n            background: rgba(17, 24, 39, 0.8);\n            border: 1px solid rgba(255,255,255,0.08);\n            border-radius: 12px;\n            padding: 12px;\n        }\n        .challenge {\n            font-size: 13px;\n            color: var(--muted);\n        }\n        .legend {\n            position: absolute;\n            bottom: 8px;\n            right: 8px;\n            font-size: 11px;\n            color: var(--muted);\n            background: rgba(0,0,0,0.35);\n            padding: 6px 8px;\n            border-radius: 8px;\n            border: 1px solid rgba(255,255,255,0.1);\n        }\n        @media (min-width: 720px) {\n            canvas { height: 420px; }\n        }\n    </style>\n</head>\n<body>\n    <header>\n        <h1>Light and Shadows</h1>\n        <p>Explore how light travels in straight lines to form shadows and pin-hole images.</p>\n    </header>\n    <div class=\"container\">\n        <div class=\"canvas-wrap\">\n            <canvas id=\"scene\"></canvas>\n            <div class=\"legend\">Tip: Drag sliders to change light position. Tap buttons to switch modes.</div>\n        </div>\n        <div class=\"controls\">\n            <div class=\"row\">\n                <label for=\"objectType\">Object type</label>\n                <select id=\"objectType\">\n                    <option value=\"opaque\">Wood (opaque)</option>\n                    <option value=\"transparent\">Glass (transparent)</option>\n                    <option value=\"translucent\">Frosted glass (translucent)</option>\n                </select>\n            </div>\n            <div class=\"row\">\n                <label>Object shape</label>\n                <div class=\"btn-group\">\n                    <button id=\"shape-circle\" class=\"btn-outline\">Circle</button>\n                    <button id=\"shape-square\" class=\"btn-outline\">Square</button>\n                    <button id=\"shape-hand\" class=\"btn-outline\">Hand</button>\n                </div>\n            </div>\n            <div class=\"row-2\">\n                <div>\n                    <label for=\"lightDistance\">Light distance: <span id=\"distVal\">200</span> px</label>\n                    <input id=\"lightDistance\" type=\"range\" min=\"80\" max=\"360\" value=\"200\">\n                </div>\n                <div>\n                    <label for=\"lightAngle\">Light angle: <span id=\"angleVal\">0</span>Â°</label>\n                    <input id=\"lightAngle\" type=\"range\" min=\"-45\" max=\"45\" value=\"0\">\n                </div>\n            </div>\n            <div class=\"row\">\n                <label>Mode</label>\n                <div class=\"toggle\" id=\"modeToggle\">\n                    <span id=\"modeLabel\">Shadow Mode</span>\n                    <span class=\"pill\">Tap to switch</span>\n                </div>\n            </div>\n        </div>\n        <div class=\"info\">\n            <p id=\"infoText\">You're seeing a ___ shadow because the object is ___.</p>\n        </div>\n        <div class=\"footer\">\n            <button id=\"resetBtn\" class=\"btn-danger\">Reset</button>\n            <div class=\"challenge\" id=\"challengeText\">Try This! Make the shadow the same size as the object by moving the light.</div>\n        </div>\n    </div>\n    <script>\n        const canvas = document.getElementById('scene');\n        const ctx = canvas.getContext('2d');\n        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));\n\n        function resizeCanvas() {\n            const rect = canvas.getBoundingClientRect();\n            canvas.width = Math.floor(rect.width * dpr);\n            canvas.height = Math.floor(rect.height * dpr);\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n        window.addEventListener('resize', resizeCanvas);\n        resizeCanvas();\n\n        const state = {\n            mode: 'shadow', // 'shadow' | 'pinhole'\n            objectType: 'opaque', // 'opaque' | 'transparent' | 'translucent'\n            objectShape: 'circle', // 'circle' | 'square' | 'hand'\n            lightDistance: 200,\n            lightAngleDeg: 0,\n            screenDistance: 160,\n            objectX: 0.5,\n            objectY: 0.5,\n            objectSize: 80,\n            pinholeX: 0.5,\n            pinholeY: 0.5,\n            pinholeSize: 8,\n            virtualObjectSize: 60,\n            virtualObjectX: 0.5,\n            virtualObjectY: 0.35,\n            showRays: true,\n            showLabels: true\n        };\n\n        const ui = {\n            modeToggle: document.getElementById('modeToggle'),\n            modeLabel: document.getElementById('modeLabel'),\n            objectType: document.getElementById('objectType'),\n            lightDistance: document.getElementById('lightDistance'),\n            lightAngle: document.getElementById('lightAngle'),\n            distVal: document.getElementById('distVal'),\n            angleVal: document.getElementById('angleVal'),\n            infoText: document.getElementById('infoText'),\n            resetBtn: document.getElementById('resetBtn'),\n            shapeCircle: document.getElementById('shape-circle'),\n            shapeSquare: document.getElementById('shape-square'),\n            shapeHand: document.getElementById('shape-hand'),\n            challengeText: document.getElementById('challengeText')\n        };\n\n        function setMode(mode) {\n            state.mode = mode;\n            ui.modeLabel.textContent = mode === 'shadow' ? 'Shadow Mode' : 'Pin-Hole Camera Mode';\n            ui.challengeText.textContent = mode === 'shadow' ?\n                'Try This! Make the shadow the same size as the object by moving the light.' :\n                'Try This! Move the light to see how the inverted image changes.';\n            updateInfo();\n            draw();\n        }\n\n        function setObjectType(type) {\n            state.objectType = type;\n            updateInfo();\n            draw();\n        }\n\n        function setObjectShape(shape) {\n            state.objectShape = shape;\n            draw();\n        }\n\n        function setLightDistance(val) {\n            state.lightDistance = val;\n            ui.distVal.textContent = val;\n            draw();\n        }\n\n        function setLightAngle(val) {\n            state.lightAngleDeg = val;\n            ui.angleVal.textContent = val;\n            draw();\n        }\n\n        function resetAll() {\n            state.mode = 'shadow';\n            state.objectType = 'opaque';\n            state.objectShape = 'circle';\n            state.lightDistance = 200;\n            state.lightAngleDeg = 0;\n            ui.objectType.value = 'opaque';\n            ui.lightDistance.value = '200';\n            ui.lightAngle.value = '0';\n            ui.distVal.textContent = '200';\n            ui.angleVal.textContent = '0';\n            setMode('shadow');\n            setObjectType('opaque');\n            setObjectShape('circle');\n            setLightDistance(200);\n            setLightAngle(0);\n        }\n\n        function updateInfo() {\n            const modeText = state.mode === 'shadow' ? 'Shadow Mode' : 'Pin-Hole Camera Mode';\n            const typeText = state.objectType === 'opaque' ? 'opaque' :\n                             state.objectType === 'transparent' ? 'transparent' : 'translucent';\n            const shadowType = state.objectType === 'opaque' ? 'sharp and dark' :\n                               state.objectType === 'transparent' ? 'no shadow' : 'faint and gray';\n            ui.infoText.textContent = `You're seeing a ${shadowType} because the object is ${typeText}. (${modeText})`;\n        }\n\n        function draw() {\n            const w = canvas.clientWidth;\n            const h = canvas.clientHeight;\n            ctx.clearRect(0, 0, w, h);\n\n            // Scene layout\n            const margin = 20;\n            const left = margin;\n            const right = w - margin;\n            const center = (left + right) / 2;\n            const centerY = h / 2;\n\n            // Light source\n            const lightAngleRad = (state.lightAngleDeg * Math.PI) / 180;\n            const lightX = left - state.lightDistance * Math.cos(lightAngleRad);\n            const lightY = centerY - state.lightDistance * Math.sin(lightAngleRad);\n\n            // Object\n            const objX = center;\n            const objY = centerY;\n\n            // Screen\n            const screenX = right;\n            const screenTop = 40;\n            const screenBottom = h - 40;\n            const screenW = 10;\n\n            // Draw background grid faintly\n            drawGrid(w, h);\n\n            // Draw light source\n            drawLightSource(lightX, lightY);\n\n            if (state.mode === 'shadow') {\n                // Draw object\n                drawObject(objX, objY, state.objectShape, state.objectSize, state.objectType);\n                // Draw rays and shadow\n                drawShadowRays(lightX, lightY, objX, objY, state.objectShape, state.objectSize, state.objectType, screenX, screenTop, screenBottom);\n                // Draw screen\n                drawScreen(screenX, screenTop, screenBottom, screenW);\n            } else {\n                // Pin-hole camera mode\n                drawPinholeCamera(left, right, centerY, screenTop, screenBottom, screenW, objX, objY);\n                drawVirtualObject(state.virtualObjectX, state.virtualObjectY, state.virtualObjectSize, w, h);\n                drawPinholeRays(lightX, lightY, objX, objY, state.pinholeX, state.pinholeY, state.pinholeSize, screenX, screenTop, screenBottom, w, h);\n            }\n\n            // Labels\n            if (state.showLabels) {\n                drawLabels(w, h, lightX, lightY, objX, objY, screenX, screenTop, screenBottom);\n            }\n        }\n\n        function drawGrid(w, h) {\n            ctx.save();\n            ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n            ctx.lineWidth = 1;\n            for (let x = 0; x < w; x += 24) {\n                ctx.beginPath();\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, h);\n                ctx.stroke();\n            }\n            for (let y = 0; y < h; y += 24) {\n                ctx.beginPath();\n                ctx.moveTo(0, y);\n                ctx.lineTo(w, y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n\n        function drawLightSource(x, y) {\n            // Glow\n            const grad = ctx.createRadialGradient(x, y, 0, x, y, 120);\n            grad.addColorStop(0, 'rgba(255,255,255,0.35)');\n            grad.addColorStop(1, 'rgba(255,255,255,0)');\n            ctx.fillStyle = grad;\n            ctx.beginPath();\n            ctx.arc(x, y, 120, 0, Math.PI * 2);\n            ctx.fill();\n            // Bulb\n            ctx.fillStyle = '#fbbf24';\n            ctx.beginPath();\n            ctx.arc(x, y, 10, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.strokeStyle = 'rgba(0,0,0,0.3)';\n            ctx.lineWidth = 2;\n            ctx.stroke();\n        }\n\n        function drawObject(x, y, shape, size, type) {\n            ctx.save();\n            ctx.translate(x, y);\n            if (type === 'opaque') {\n                ctx.fillStyle = '#374151';\n                ctx.strokeStyle = 'rgba(0,0,0,0.5)';\n                ctx.lineWidth = 2;\n            } else if (type === 'transparent') {\n                ctx.fillStyle = 'rgba(59,130,246,0.25)';\n                ctx.strokeStyle = 'rgba(59,130,246,0.6)';\n                ctx.lineWidth = 2;\n            } else {\n                ctx.fillStyle = 'rgba(148,163,184,0.35)';\n                ctx.strokeStyle = 'rgba(148,163,184,0.7)';\n                ctx.lineWidth = 2;\n            }\n            if (shape === 'circle') {\n                ctx.beginPath();\n                ctx.arc(0, 0, size, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.stroke();\n            } else if (shape === 'square') {\n                ctx.beginPath();\n                ctx.rect(-size, -size, size * 2, size * 2);\n                ctx.fill();\n                ctx.stroke();\n            } else {\n                // Hand silhouette (simple)\n                ctx.beginPath();\n                ctx.moveTo(0, -size);\n                ctx.lineTo(size * 0.6, -size * 0.2);\n                ctx.lineTo(size * 0.3, size * 0.1);\n                ctx.lineTo(size * 0.5, size * 0.6);\n                ctx.lineTo(0, size * 0.4);\n                ctx.lineTo(-size * 0.5, size * 0.6);\n                ctx.lineTo(-size * 0.3, size * 0.1);\n                ctx.lineTo(-size * 0.6, -size * 0.2);\n                ctx.closePath();\n                ctx.fill();\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n\n        function drawShadowRays(lightX, lightY, objX, objY, shape, size, type, screenX, screenTop, screenBottom) {\n            const rays = 24;\n            const step = (screenBottom - screenTop) / rays;\n            const top = screenTop;\n            const bottom = screenBottom;\n            const objBounds = getObjectBounds(objX, objY, shape, size);\n            const leftBound = objBounds.left;\n            const rightBound = objBounds.right;\n            const topBound = objBounds.top;\n            const bottomBound = objBounds.bottom;\n\n            // Draw rays from light to screen\n            for (let i = 0; i <= rays; i++) {\n                const y = top + i * step;\n                const dirX = screenX - lightX;\n                const dirY = y - lightY;\n                const len = Math.hypot(dirX, dirY);\n                const ux = dirX / len;\n                const uy = dirY / len;\n\n                // Check intersection with object bounds\n                let blocked = false;\n                if (type !== 'transparent') {\n                    // Ray-box intersection\n                    const t1 = (leftBound - lightX) / (ux || 1e-9);\n                    const t2 = (rightBound - lightX) / (ux || 1e-9);\n                    const t3 = (topBound - lightY) / (uy || 1e-9);\n                    const t4 = (bottomBound - lightY) / (uy || 1e-9);\n                    const tmin = Math.max(Math.min(t1, t2), Math.min(t3, t4));\n                    const tmax = Math.min(Math.max(t1, t2), Math.max(t3, t4));\n                    if (tmax >= Math.max(0, tmin)) {\n                        blocked = true;\n                    }\n                }\n\n                ctx.save();\n                ctx.strokeStyle = blocked ? 'rgba(255,255,255,0.08)' : 'rgba(255,255,255,0.25)';\n                ctx.lineWidth = 1;\n                ctx.beginPath();\n                ctx.moveTo(lightX, lightY);\n                ctx.lineTo(screenX, y);\n                ctx.stroke();\n                ctx.restore();\n            }\n\n            // Draw shadow on screen\n            ctx.save();\n            ctx.fillStyle = type === 'opaque' ? 'rgba(0,0,0,0.85)' :\n                             type === 'transparent' ? 'rgba(0,0,0,0)' : 'rgba(0,0,0,0.35)';\n            if (type !== 'transparent') {\n                // Shadow region on screen\n                const shadowTop = Math.max(screenTop, topBound);\n                const shadowBottom = Math.min(screenBottom, bottomBound);\n                if (shadowTop < shadowBottom) {\n                    ctx.fillRect(screenX - 10, shadowTop, 10, shadowBottom - shadowTop);\n                }\n            }\n            ctx.restore();\n        }\n\n        function drawScreen(x, top, bottom, w) {\n            ctx.save();\n            ctx.fillStyle = 'rgba(255,255,255,0.08)';\n            ctx.fillRect(x - w, top, w, bottom - top);\n            ctx.strokeStyle = 'rgba(255,255,255,0.15)';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(x - w, top, w, bottom - top);\n            ctx.restore();\n        }\n\n        function drawPinholeCamera(left, right, centerY, screenTop, screenBottom, screenW, objX, objY) {\n            // Camera box\n            const boxLeft = left + 60;\n            const boxRight = right - 60;\n            const boxTop = screenTop + 20;\n            const boxBottom = screenBottom - 20;\n            ctx.save();\n            ctx.fillStyle = 'rgba(31,41,55,0.9)';\n            ctx.strokeStyle = 'rgba(255,255,255,0.15)';\n            ctx.lineWidth = 2;\n            ctx.fillRect(boxLeft, boxTop, boxRight - boxLeft, boxBottom - boxTop);\n            ctx.strokeRect(boxLeft, boxTop, boxRight - boxLeft, boxBottom - boxTop);\n            // Pin-hole\n            const phX = objX;\n            const phY = objY;\n            ctx.fillStyle = '#111827';\n            ctx.beginPath();\n            ctx.arc(phX, phY, state.pinholeSize, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.strokeStyle = 'rgba(255,255,255,0.3)';\n            ctx.stroke();\n            // Inner screen\n            ctx.fillStyle = 'rgba(255,255,255,0.08)';\n            ctx.fillRect(boxRight - screenW, boxTop, screenW, boxBottom - boxTop);\n            ctx.strokeStyle = 'rgba(255,255,255,0.15)';\n            ctx.strokeRect(boxRight - screenW, boxTop, screenW, boxBottom - boxTop);\n            ctx.restore();\n        }\n\n        function drawVirtualObject(normX, normY, size, w, h) {\n            const x = normX * w;\n            const y = normY * h;\n            ctx.save();\n            ctx.fillStyle = 'rgba(239,68,68,0.25)';\n            ctx.strokeStyle = 'rgba(239,68,68,0.8)';\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            ctx.arc(x, y, size, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.stroke();\n            ctx.restore();\n        }\n\n        function drawPinholeRays(lightX, lightY, objX, objY, phNormX, phNormY, phSize, screenX, screenTop, screenBottom, w, h) {\n            const rays = 18;\n            const step = (screenBottom - screenTop) / rays;\n            const top = screenTop;\n            const bottom = screenBottom;\n            const phX = objX;\n            const phY = objY;\n\n            for (let i = 0; i <= rays; i++) {\n                const y = top + i * step;\n                // Ray from light to pinhole\n                ctx.save();\n                ctx.strokeStyle = 'rgba(255,255,255,0.25)';\n                ctx.lineWidth = 1;\n                ctx.beginPath();\n                ctx.moveTo(lightX, lightY);\n                ctx.lineTo(phX, phY);\n                ctx.stroke();\n                ctx.restore();\n                // Ray from pinhole to screen\n                ctx.save();\n                ctx.strokeStyle = 'rgba(34,197,94,0.6)';\n                ctx.lineWidth = 1;\n                ctx.beginPath();\n                ctx.moveTo(phX, phY);\n                ctx.lineTo(screenX, y);\n                ctx.stroke();\n                ctx.restore();\n            }\n\n            // Draw inverted image on inner screen\n            const boxRight = screenX;\n            const boxLeft = objX;\n            const boxTop = screenTop + 20;\n            const boxBottom = screenBottom - 20;\n            const imageW = 10;\n            const imageH = boxBottom - boxTop;\n            const imageX = boxRight - imageW;\n            const imageY = boxTop;\n\n            // Simulate inverted image\n            ctx.save();\n            ctx.fillStyle = 'rgba(239,68,68,0.5)';\n            ctx.fillRect(imageX, imageY, imageW, imageH);\n            ctx.restore();\n        }\n\n        function drawLabels(w, h, lightX, lightY, objX, objY, screenX, screenTop, screenBottom) {\n            ctx.save();\n            ctx.fillStyle = 'rgba(255,255,255,0.8)';\n            ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial';\n            ctx.fillText('Light', lightX + 12, lightY - 12);\n            ctx.fillText('Object', objX + 12, objY - 12);\n            ctx.fillText('Screen', screenX + 12, screenTop + 16);\n            ctx.restore();\n        }\n\n        function getObjectBounds(x, y, shape, size) {\n            if (shape === 'circle') {\n                return { left: x - size, right: x + size, top: y - size, bottom: y + size };\n            } else if (shape === 'square') {\n                return { left: x - size, right: x + size, top: y - size, bottom: y + size };\n            } else {\n                // Hand bounds (approximate)\n                return { left: x - size * 0.6, right: x + size * 0.6, top: y - size, bottom: y + size * 0.6 };\n            }\n        }\n\n        // UI events\n        ui.modeToggle.addEventListener('click', () => {\n            setMode(state.mode === 'shadow' ? 'pinhole' : 'shadow');\n        });\n        ui.objectType.addEventListener('change', (e) => setObjectType(e.target.value));\n        ui.lightDistance.addEventListener('input', (e) => setLightDistance(parseInt(e.target.value, 10)));\n        ui.lightAngle.addEventListener('input', (e) => setLightAngle(parseInt(e.target.value, 10)));\n        ui.resetBtn.addEventListener('click', resetAll);\n        ui.shapeCircle.addEventListener('click', () => setObjectShape('circle'));\n        ui.shapeSquare.addEventListener('click', () => setObjectShape('square'));\n        ui.shapeHand.addEventListener('click', () => setObjectShape('hand'));\n\n        // Initial draw\n        setMode('shadow');\n        setObjectType('opaque');\n        setObjectShape('circle');\n        setLightDistance(200);\n        setLightAngle(0);\n    </script>\n</body>\n</html>"
}