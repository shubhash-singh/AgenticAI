```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heat Flow Simulation</title>
    <style>
        :root {
            --bg: #f5f7fb;
            --card: #ffffff;
            --accent: #3b82f6;
            --accent-light: #93c5fd;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --success: #10b981;
            --error: #ef4444;
            --red-hot: #e53e3e;
            --red-hot-dark: #c53030;
            --blue-cold: #3182ce;
            --blue-cold-dark: #2c5282;
            --neutral-gray: #a0aec0;
            --particle-hot-color: #f6ad55;
            --particle-cold-color: #63b3ed;
            --arrow-color: #4a5568;
            --arrow-tip-color: #e53e3e;
            --shadow-color: rgba(0, 0, 0, 0.06);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: var(--bg);
            color: var(--text-primary);
            margin: 0;
            padding: 1rem;
            line-height: 1.6;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .container {
            max-width: 720px;
            width: 100%;
            margin: 0 auto;
            padding: 1rem;
            box-sizing: border-box;
        }

        .card {
            background-color: var(--card);
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow-color);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-sizing: border-box;
        }

        .card h2 {
            margin-top: 0;
            color: var(--accent);
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }

        #simCanvasContainer {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 350px; /* Ensure container has height even if SVG is empty initially */
        }

        #simCanvas {
            display: block;
            max-width: 100%;
            height: auto;
            background-color: var(--card); /* Match card background */
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        .control-group {
            margin-bottom: 1.25rem;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .control-label {
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #d1d5db; /* Tailwind's gray-300 */
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s ease-in-out;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            transition: background 0.2s ease-in-out;
            margin-top: -8px; /* Center thumb vertically */
        }

        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            transition: background 0.2s ease-in-out;
        }

        .value-pill {
            display: inline-block;
            background-color: var(--accent-light);
            color: var(--accent);
            font-weight: 600;
            padding: 0.3rem 0.75rem;
            border-radius: 20px;
            margin-left: 1rem;
            min-width: 50px;
            text-align: center;
            font-size: 0.9rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .stat-card {
            text-align: center;
            padding: 1rem;
            background-color: var(--card);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .formula-display {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: var(--accent-light);
            border-radius: 8px;
            font-size: 0.95rem;
            text-align: center;
            color: var(--accent);
            font-weight: 500;
        }

        .explanation-section {
            margin-top: 1.5rem;
            border-top: 1px solid #e2e8f0;
            padding-top: 1.5rem;
        }

        .explanation-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--accent);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .explanation-title::after {
            content: '+';
            font-size: 1.5rem;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .explanation-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
            padding-top: 0;
        }

        .explanation-section.active .explanation-title::after {
            content: '−';
            transform: rotate(0deg);
        }

        .explanation-section.active .explanation-content {
            max-height: 500px; /* Sufficiently large to show content */
            padding-top: 1rem;
        }

        .explanation-content ul {
            padding-left: 1.5rem;
        }

        .quiz-card {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background-color: var(--card);
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        .quiz-question {
            font-weight: 600;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .quiz-options {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .quiz-option {
            background-color: #f1f5f9; /* Slightly darker than body bg */
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .quiz-option:hover {
            background-color: #e2e8f0;
        }

        .quiz-option.correct {
            background-color: var(--success);
            color: white;
            border-color: var(--success);
            font-weight: 500;
        }

        .quiz-option.incorrect {
            background-color: var(--error);
            color: white;
            border-color: var(--error);
            font-weight: 500;
        }

        .quiz-option span {
            flex-grow: 1;
            margin-right: 0.5rem;
        }

        .quiz-explanation {
            font-size: 0.9rem;
            margin-top: 0.5rem;
            opacity: 0.8;
            font-style: italic;
        }

        .draggable-handle {
            width: 10px;
            background-color: var(--accent-light);
            cursor: ew-resize;
            height: 100%;
            position: absolute;
            top: 0;
            z-index: 2; /* Above SVG elements */
            border-radius: 5px;
            transition: background-color 0.2s ease;
        }
        .draggable-handle:hover {
            background-color: var(--accent);
        }

        .temp-gauge-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 0.3rem;
        }

        .temp-gauge-value {
            font-size: 1.3rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 0.5rem;
        }

        .particle {
            transition: transform 0.1s linear; /* Smooth movement */
        }
    </style>
</head>
<body>
    <div class="container">

        <div class="card">
            <h2 class="card-title">Heat Flow Simulation</h2>
            <p>Explore how heat energy moves from hotter objects to colder objects.</p>
            <div id="simCanvasContainer">
                <svg id="simCanvas" viewBox="0 0 500 350" preserveAspectRatio="xMidYMid meet">
                    <!-- Environment -->
                    <rect id="envRect" x="175" y="100" width="150" height="150" fill="#e2e8f0" rx="8" ry="8"></rect>

                    <!-- Hot Object -->
                    <rect id="hotRect" x="50" y="100" width="100" height="150" rx="8" ry="8"></rect>
                    <text x="100" y="270" text-anchor="middle" font-size="12" fill="var(--text-secondary)">Hot Object</text>

                    <!-- Cold Object -->
                    <rect id="coldRect" x="350" y="100" width="100" height="150" rx="8" ry="8"></rect>
                    <text x="400" y="270" text-anchor="middle" font-size="12" fill="var(--text-secondary)">Cold Object</text>

                    <!-- Temperature Gauges -->
                    <text id="hotTempLabel" x="75" y="45" text-anchor="middle" font-size="14" class="temp-gauge-label">Temperature</text>
                    <rect id="hotTempGauge" x="50" y="55" width="100" height="10" rx="5" ry="5" fill="var(--red-hot)"></rect>
                    <text id="hotTempDisplay" x="100" y="35" text-anchor="middle" font-size="18" font-weight="bold" fill="var(--red-hot-dark)"></text>

                    <text id="coldTempLabel" x="375" y="45" text-anchor="middle" font-size="14" class="temp-gauge-label">Temperature</text>
                    <rect id="coldTempGauge" x="350" y="55" width="100" height="10" rx="5" ry="5" fill="var(--blue-cold)"></rect>
                    <text id="coldTempDisplay" x="400" y="35" text-anchor="middle" font-size="18" font-weight="bold" fill="var(--blue-cold-dark)"></text>

                    <!-- Heat Flow Arrow -->
                    <g id="heatFlowArrowGroup">
                        <path id="heatFlowArrow" d="M0 0 L15 0 L7.5 -15 z" fill="var(--arrow-tip-color)" transform="translate(250, 175)"></path>
                        <line id="heatFlowLine" stroke-width="3" stroke="var(--arrow-color)" stroke-linecap="round"></line>
                        <text x="250" y="205" text-anchor="middle" font-size="12" fill="var(--text-secondary)">Heat Flow</text>
                    </g>

                    <!-- Draggable Separator -->
                    <g id="draggableSeparatorGroup">
                        <rect id="draggableHandle" class="draggable-handle" x="245" y="100" width="10" height="150" rx="3" ry="3"></rect>
                    </g>
                </svg>
            </div>
        </div>

        <div class="card">
            <h2 class="card-title">Controls</h2>
            <div class="control-group">
                <label for="hotTempSlider" class="control-label">Hot Object Temperature</label>
                <div style="display: flex; align-items: center; width: 100%;">
                    <input type="range" id="hotTempSlider" min="20" max="100" step="1" value="80">
                    <span id="hotTempValue" class="value-pill">80°C</span>
                </div>
            </div>
            <div class="control-group">
                <label for="coldTempSlider" class="control-label">Cold Object Temperature</label>
                <div style="display: flex; align-items: center; width: 100%;">
                    <input type="range" id="coldTempSlider" min="0" max="80" step="1" value="20">
                    <span id="coldTempValue" class="value-pill">20°C</span>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 class="card-title">Simulation Stats</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Hot Temp</div>
                    <div id="statHotTemp" class="stat-value">--°C</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Cold Temp</div>
                    <div id="statColdTemp" class="stat-value">--°C</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Temperature Difference</div>
                    <div id="statTempDiff" class="stat-value">--°C</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Heat Flow Rate</div>
                    <div id="statHeatFlowRate" class="stat-value">--</div>
                </div>
            </div>
            <div class="formula-display">
                Heat Flow Rate ∝ (T<sub>hot</sub> - T<sub>cold</sub>)
            </div>
        </div>

        <div class="card">
            <h2 class="card-title">Key Concepts</h2>
            <div class="explanation-section">
                <div class="explanation-title">Heat is Energy in Motion</div>
                <div class="explanation-content">
                    <p>Heat is a form of energy that represents the total kinetic energy of the particles within a substance. When we talk about heat flow, we are describing the transfer of this kinetic energy from one object to another.</p>
                    <ul>
                        <li>Hotter objects have particles with higher average kinetic energy (they move faster).</li>
                        <li>Colder objects have particles with lower average kinetic energy (they move slower).</li>
                    </ul>
                </div>
            </div>
            <div class="explanation-section">
                <div class="explanation-title">Temperature Difference Drives Heat Flow</div>
                <div class="explanation-content">
                    <p>Heat naturally moves from areas of high concentration (high temperature) to areas of low concentration (low temperature). This is similar to how water flows downhill or how perfume spreads in a room. The greater the difference in temperature, the faster the heat will flow.</p>
                    <ul>
                        <li>Heat flow continues until both objects reach the same temperature (thermal equilibrium).</li>
                        <li>The rate of heat flow is directly proportional to the temperature difference.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 class="card-title">Quiz Time!</h2>
            <div id="quizContainer">
                <!-- Quiz questions will be dynamically added here -->
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- State Management ---
            let state = {
                hotTemp: 80,
                coldTemp: 20,
                separatorPosition: 250, // Initial position of the draggable handle
                particleSpeedFactor: 0.1, // Multiplier for particle speed based on temperature
                particleDensityFactor: 0.05, // Multiplier for particle density based on temperature
                distanceFactor: 0.002, // Factor to reduce heat flow based on distance
                baseHeatFlow: 1.5 // Base rate of heat flow
            };

            // --- DOM References ---
            const simCanvas = document.getElementById('simCanvas');
            const hotRect = document.getElementById('hotRect');
            const coldRect = document.getElementById('coldRect');
            const envRect = document.getElementById('envRect');
            const hotTempGauge = document.getElementById('hotTempGauge');
            const coldTempGauge = document.getElementById('coldTempGauge');
            const hotTempDisplay = document.getElementById('hotTempDisplay');
            const coldTempDisplay = document.getElementById('coldTempDisplay');
            const hotTempSlider = document.getElementById('hotTempSlider');
            const coldTempSlider = document.getElementById('coldTempSlider');
            const hotTempValue = document.getElementById('hotTempValue');
            const coldTempValue = document.getElementById('coldTempValue');
            const statHotTemp = document.getElementById('statHotTemp');
            const statColdTemp = document.getElementById('statColdTemp');
            const statTempDiff = document.getElementById('statTempDiff');
            const statHeatFlowRate = document.getElementById('statHeatFlowRate');
            const heatFlowArrow = document.getElementById('heatFlowArrow');
            const heatFlowLine = document.getElementById('heatFlowLine');
            const draggableHandle = document.getElementById('draggableHandle');
            const explanationSections = document.querySelectorAll('.explanation-section');
            const quizContainer = document.getElementById('quizContainer');

            const particles = []; // Array to hold particle objects
            const MAX_PARTICLES = 150;

            // --- Helper Functions ---
            function updateGaugeColor(gauge, temp) {
                const maxTemp = 100; // Max temp for hot, relevant for scaling color
                const minTemp = 0; // Min temp for cold, relevant for scaling color

                let normalizedTemp;
                if (gauge === hotTempGauge) {
                    normalizedTemp = (temp - hotTempSlider.min) / (hotTempSlider.max - hotTempSlider.min);
                    // Red to Orange
                    const red = Math.min(255, 229 + normalizedTemp * (255 - 229)); // 229 (e53e3e) to 255 (white)
                    const green = Math.min(255, 48 + normalizedTemp * (128 - 48)); // 48 (e53e3e) to 128 (white)
                    const blue = Math.min(255, 62 + normalizedTemp * (255 - 62)); // 62 (e53e3e) to 255 (white)
                    gauge.setAttribute('fill', `rgb(${red}, ${green}, ${blue})`);
                } else if (gauge === coldTempGauge) {
                    normalizedTemp = (temp - coldTempSlider.min) / (coldTempSlider.max - coldTempSlider.min);
                    // Blue to Cyan
                    const red = Math.min(255, 49 + normalizedTemp * (94 - 49)); // 49 (3182ce) to 94 (white)
                    const green = Math.min(255, 130 + normalizedTemp * (255 - 130)); // 130 (3182ce) to 255 (white)
                    const blue = Math.min(255, 206 + normalizedTemp * (255 - 206)); // 206 (3182ce) to 255 (white)
                    gauge.setAttribute('fill', `rgb(${red}, ${green}, ${blue})`);
                }
            }

            function generateParticles(count, temp, container) {
                particles.length = 0; // Clear existing particles
                const containerRect = container.getBoundingClientRect();
                const svgRect = simCanvas.getBoundingClientRect();
                const viewBox = simCanvas.viewBox.baseVal;

                const scaleX = viewBox.width / svgRect.width;
                const scaleY = viewBox.height / svgRect.height;

                for (let i = 0; i < count; i++) {
                    const x = Math.random() * container.width.baseVal.value + container.x.baseVal.value;
                    const y = Math.random() * container.height.baseVal.value + container.y.baseVal.value;

                    const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    particle.setAttribute('r', '3');
                    particle.setAttribute('class', 'particle');
                    const color = temp > 50 ? 'var(--particle-hot-color)' : 'var(--particle-cold-color)';
                    particle.setAttribute('fill', color);
                    particle.setAttribute('cx', x);
                    particle.setAttribute('cy', y);
                    simCanvas.appendChild(particle);
                    particles.push({ element: particle, x: x, y: y, temp: temp });
                }
            }

            function updateParticles() {
                const hotRectBBox = hotRect.getBBox();
                const coldRectBBox = coldRect.getBBox();
                const envRectBBox = envRect.getBBox();
                const particleRadius = 3;

                particles.forEach(p => {
                    let dx = 0, dy = 0;
                    let currentTemp = p.temp;
                    let color = p.temp > 50 ? 'var(--particle-hot-color)' : 'var(--particle-cold-color)';

                    // Assign to new object if it drifts out
                    if (p.x < hotRectBBox.x + particleRadius) p.x = hotRectBBox.x + particleRadius;
                    if (p.x > hotRectBBox.x + hotRectBBox.width - particleRadius) p.x = hotRectBBox.x + hotRectBBox.width - particleRadius;
                    if (p.y < hotRectBBox.y + particleRadius) p.y = hotRectBBox.y + particleRadius;
                    if (p.y > hotRectBBox.y + hotRectBBox.height - particleRadius) p.y = hotRectBBox.y + hotRectBBox.height - particleRadius;

                    if (p.x < coldRectBBox.x + particleRadius) p.x = coldRectBBox.x + particleRadius;
                    if (p.x > coldRectBBox.x + coldRectBBox.width - particleRadius) p.x = coldRectBBox.x + coldRectBBox.width - particleRadius;
                    if (p.y < coldRectBBox.y + particleRadius) p.y = coldRectBBox.y + particleRadius;
                    if (p.y > coldRectBBox.y + coldRectBBox.height - particleRadius) p.y = coldRectBBox.y + coldRectBBox.height - particleRadius;

                    // Movement within hot object
                    if (p.x >= hotRectBBox.x && p.x <= hotRectBBox.x + hotRectBBox.width &&
                        p.y >= hotRectBBox.y && p.y <= hotRectBBox.y + hotRectBBox.height) {
                        dx = (Math.random() - 0.5) * state.particleSpeedFactor * p.temp * 0.5;
                        dy = (Math.random() - 0.5) * state.particleSpeedFactor * p.temp * 0.5;
                        currentTemp = state.hotTemp;
                        color = 'var(--particle-hot-color)';
                    }
                    // Movement within cold object
                    else if (p.x >= coldRectBBox.x && p.x <= coldRectBBox.x + coldRectBBox.width &&
                             p.y >= coldRectBBox.y && p.y <= coldRectBBox.y + coldRectBBox.height) {
                        dx = (Math.random() - 0.5) * state.particleSpeedFactor * p.temp * 0.5;
                        dy = (Math.random() - 0.5) * state.particleSpeedFactor * p.temp * 0.5;
                        currentTemp = state.coldTemp;
                        color = 'var(--particle-cold-color)';
                    }
                    // Drift towards/away from environment
                    else {
                         // Simplified: particles mostly stay within their assigned objects.
                         // More complex simulation would have particles move between objects.
                         // For now, just keep them contained or reset if they escape.
                    }
                    p.temp = currentTemp; // Update particle temp for consistent color
                    p.element.setAttribute('fill', color);


                    p.x += dx;
                    p.y += dy;

                    // Keep particles within their current object's bounds, bouncing slightly
                    if (p.x < hotRectBBox.x + particleRadius) { p.x = hotRectBBox.x + particleRadius; dx *= -0.5; }
                    if (p.x > hotRectBBox.x + hotRectBBox.width - particleRadius) { p.x = hotRectBBox.x + hotRectBBox.width - particleRadius; dx *= -0.5; }
                    if (p.y < hotRectBBox.y + particleRadius) { p.y = hotRectBBox.y + particleRadius; dy *= -0.5; }
                    if (p.y > hotRectBBox.y + hotRectBBox.height - particleRadius) { p.y = hotRectBBox.y + hotRectBBox.height - particleRadius; dy *= -0.5; }

                    if (p.x < coldRectBBox.x + particleRadius) { p.x = coldRectBBox.x + particleRadius; dx *= -0.5; }
                    if (p.x > coldRectBBox.x + coldRectBBox.width - particleRadius) { p.x = coldRectBBox.x + coldRectBBox.width - particleRadius; dx *= -0.5; }
                    if (p.y < coldRectBBox.y + particleRadius) { p.y = coldRectBBox.y + particleRadius; dy *= -0.5; }
                    if (p.y > coldRectBBox.y + coldRectBBox.height - particleRadius) { p.y = coldRectBBox.y + coldRectBBox.height - particleRadius; dy *= -0.5; }


                    p.element.setAttribute('cx', p.x);
                    p.element.setAttribute('cy', p.y);
                });
            }

            function calculateHeatFlowRate() {
                const tempDiff = state.hotTemp - state.coldTemp;
                if (tempDiff <= 0) return 0;

                // Simulate effect of separator position on distance
                const separatorCenter = state.separatorPosition + draggableHandle.width.baseVal.value / 2;
                const distance = Math.abs(separatorCenter - (envRect.x.baseVal.value + envRect.width.baseVal.value / 2));
                const distancePenalty = (distance / 100) * state.distanceFactor; // Max distance ~100

                return state.baseHeatFlow * tempDiff * (1 - distancePenalty);
            }

            function updateSimulation() {
                // Update State variables from UI
                state.hotTemp = parseInt(hotTempSlider.value);
                state.coldTemp = parseInt(coldTempSlider.value);

                // Update displayed values and colors
                hotTempDisplay.textContent = `${state.hotTemp}°C`;
                coldTempDisplay.textContent = `${state.coldTemp}°C`;
                hotTempValue.textContent = `${state.hotTemp}°C`;
                coldTempValue.textContent = `${state.coldTemp}°C`;

                updateGaugeColor(hotTempGauge, state.hotTemp);
                updateGaugeColor(coldTempGauge, state.coldTemp);

                // Update stats
                statHotTemp.textContent = `${state.hotTemp}°C`;
                statColdTemp.textContent = `${state.coldTemp}°C`;
                const tempDiff = state.hotTemp - state.coldTemp;
                statTempDiff.textContent = tempDiff >= 0 ? `${tempDiff}°C` : '0°C';
                const heatFlowRate = calculateHeatFlowRate();
                statHeatFlowRate.textContent = heatFlowRate.toFixed(1);

                // Update particle density and speed based on temperature
                const hotParticleCount = Math.max(0, Math.min(MAX_PARTICLES, Math.round(state.hotTemp * state.particleDensityFactor)));
                const coldParticleCount = Math.max(0, Math.min(MAX_PARTICLES, Math.round(state.coldTemp * state.particleDensityFactor)));

                // Update particle speeds
                particles.forEach(p => {
                    if (p.element.parentNode === simCanvas) { // Ensure it's still in the DOM
                        if (p.x >= hotRect.x.baseVal.value && p.x <= hotRect.x.baseVal.value + hotRect.width.baseVal.value &&
                            p.y >= hotRect.y.baseVal.value && p.y <= hotRect.y.baseVal.value + hotRect.height.baseVal.value) {
                            p.temp = state.hotTemp;
                        } else if (p.x >= coldRect.x.baseVal.value && p.x <= coldRect.x.baseVal.value + coldRect.width.baseVal.value &&
                                   p.y >= coldRect.y.baseVal.value && p.y <= coldRect.y.baseVal.value + coldRect.height.baseVal.value) {
                            p.temp = state.coldTemp;
                        }
                    }
                });


                // Re-generate particles if count changes significantly
                const currentHotParticles = particles.filter(p =>
                    p.x >= hotRect.x.baseVal.value && p.x <= hotRect.x.baseVal.value + hotRect.width.baseVal.value &&
                    p.y >= hotRect.y.baseVal.value && p.y <= hotRect.y.baseVal.value + hotRect.height.baseVal.value
                ).length;
                const currentColdParticles = particles.filter(p =>
                    p.x >= coldRect.x.baseVal.value && p.x <= coldRect.x.baseVal.value + coldRect.width.baseVal.value &&
                    p.y >= coldRect.y.baseVal.value && p.y <= coldRect.y.baseVal.value + coldRect.height.baseVal.value
                ).length;

                if (Math.abs(currentHotParticles - hotParticleCount) > 5) {
                    generateParticles(hotParticleCount, state.hotTemp, hotRect);
                    generateParticles(coldParticleCount, state.coldTemp, coldRect); // Regenerate both for consistency
                } else {
                     updateParticles(); // Just update existing ones if count is fine
                }


                // Update Heat Flow Arrow and Line
                const arrowStartScale = 50; // SVG units
                const arrowEndScale = 450; // SVG units

                if (state.hotTemp > state.coldTemp) {
                    const arrowWidth = Math.max(0, (state.hotTemp - state.coldTemp) * 1.5); // Arrow length based on temp diff
                    const arrowMidPoint = envRect.x.baseVal.value + envRect.width.baseVal.value / 2; // Center of environment

                    // Position arrow and line to span between objects, over environment
                    const arrowHeight = 20;
                    const arrowTipHeight = 15; // For the triangle
                    const arrowBaseWidth = 10;

                    const lineStartX = hotRect.x.baseVal.value + hotRect.width.baseVal.value;
                    const lineEndX = coldRect.x.baseVal.value;
                    const lineY = hotRect.y.baseVal.value + hotRect.height.baseVal.value / 2;

                    heatFlowLine.setAttribute('x1', lineStartX);
                    heatFlowLine.setAttribute('y1', lineY);
                    heatFlowLine.setAttribute('x2', lineEndX);
                    heatFlowLine.setAttribute('y2', lineY);

                    // Center the arrow between the objects, visually indicating flow
                    const arrowXOffset = (lineEndX - lineStartX) / 2 + lineStartX;
                    const arrowYOffset = lineY - arrowHeight / 2;
                    heatFlowArrowGroup.setAttribute('transform', `translate(${arrowXOffset}, ${arrowYOffset}) rotate(${lineEndX < lineStartX ? 0 : 180})`); // Rotate if cold is left of hot

                    heatFlowArrow.setAttribute('d', `M${-arrowBaseWidth/2} ${arrowHeight/2} L0 ${arrowHeight/2 + arrowTipHeight} L${arrowBaseWidth/2} ${arrowHeight/2} z`);
                    heatFlowArrow.setAttribute('fill', 'var(--arrow-tip-color)');

                    // Adjust arrow position based on separator
                    const separatorMidX = state.separatorPosition + draggableHandle.width.baseVal.value / 2;
                    const desiredArrowX = envRect.x.baseVal.value + envRect.width.baseVal.value / 2;

                    // Smoothly move arrow towards center of environment, but ensure it stays between objects
                    const targetArrowX = desiredArrowX;
                    heatFlowArrowGroup.setAttribute('transform', `translate(${targetArrowX}, ${arrowYOffset}) rotate(${lineEndX < lineStartX ? 0 : 180})`);
                     // Ensure the arrow head isn't clipped or positioned poorly relative to the separator
                    const arrowVisualX = targetArrowX; // Center of the arrow group
                    const handleMidX = state.separatorPosition + draggableHandle.width.baseVal.value / 2;
                    const arrowEdge = arrowVisualX + (lineEndX < lineStartX ? -arrowBaseWidth/2 : arrowBaseWidth/2);

                    // The transform is applied to the group, so translate is in group's coordinate system
                    // We need to re-calculate transform based on the actual line endpoints to get correct rotation
                    const angle = Math.atan2(heatFlowLine.getAttribute('y2') - heatFlowLine.getAttribute('y1'), heatFlowLine.getAttribute('x2') - heatFlowLine.getAttribute('x1')) * 180 / Math.PI;
                    heatFlowArrowGroup.setAttribute('transform', `translate(${targetArrowX}, ${lineY}) rotate(${angle})`);

                    // Make arrow more visible when flow is significant
                    heatFlowLine.setAttribute('stroke-width', Math.max(3, heatFlowRate * 0.5));
                    heatFlowArrow.setAttribute('fill', 'var(--arrow-tip-color)');
                    heatFlowLine.style.display = 'block';
                    heatFlowArrow.style.display = 'block';
                    heatFlowArrowGroup.style.display = 'block';


                } else {
                    heatFlowLine.style.display = 'none';
                    heatFlowArrow.style.display = 'none';
                    heatFlowArrowGroup.style.display = 'none';
                }
            }

            // --- Event Listeners ---
            hotTempSlider.addEventListener('input', updateSimulation);
            coldTempSlider.addEventListener('input', updateSimulation);

            explanationSections.forEach(section => {
                section.addEventListener('click', () => {
                    section.classList.toggle('active');
                });
            });

            // --- Draggable Separator Logic ---
            let isDragging = false;
            let offsetX, offsetY;

            draggableHandle.addEventListener('pointerdown', (e) => {
                isDragging = true;
                // Calculate offset relative to the element's top-left corner
                const handleRect = draggableHandle.getBoundingClientRect();
                offsetX = e.clientX - handleRect.left;
                offsetY = e.clientY - handleRect.top; // Not strictly needed for horizontal drag, but good practice

                draggableHandle.style.cursor = 'grabbing';
                document.body.style.userSelect = 'none'; // Prevent text selection while dragging
            });

            document.addEventListener('pointermove', (e) => {
                if (!isDragging) return;

                const svgRect = simCanvas.getBoundingClientRect();
                const viewBox = simCanvas.viewBox.baseVal;
                const scaleX = viewBox.width / svgRect.width;
                const scaleY = viewBox.height / svgRect.height;

                let newX = (e.clientX - svgRect.left - offsetX) * scaleX;

                // Constrain the handle's horizontal movement within the simulation area
                const minX = envRect.x.baseVal.value - draggableHandle.width.baseVal.value; // Right edge of hot object
                const maxX = envRect.x.baseVal.value + envRect.width.baseVal.value; // Left edge of cold object

                newX = Math.max(minX, Math.min(newX, maxX));

                state.separatorPosition = newX;
                draggableHandle.setAttribute('x', newX);
                updateSimulation(); // Update simulation with new separator position
            });

            document.addEventListener('pointerup', () => {
                if (isDragging) {
                    isDragging = false;
                    draggableHandle.style.cursor = 'ew-resize';
                    document.body.style.userSelect = '';
                    updateSimulation(); // Final update after drag ends
                }
            });

            // --- Quiz Logic ---
            const quizQuestions = [
                {
                    question: "If the red object is at 80°C and the blue object is at 30°C, in which direction will heat flow?",
                    options: [
                        "From the red object to the blue object.",
                        "From the blue object to the red object.",
                        "Heat will not flow.",
                        "Heat will flow equally in both directions."
                    ],
                    correctAnswer: "From the red object to the blue object.",
                    explanation: "Heat always flows from a region of higher temperature to a region of lower temperature."
                },
                {
                    question: "What happens to the particles in the hotter object as its temperature increases (and heat flows out)?",
                    options: [
                        "They move faster and their kinetic energy increases.",
                        "They slow down and their kinetic energy decreases.",
                        "They stop moving.",
                        "They become more numerous but move slower."
                    ],
                    correctAnswer: "They move faster and their kinetic energy increases.",
                    explanation: "Temperature is a measure of the average kinetic energy of the particles. Higher temperature means faster particle movement and greater kinetic energy."
                },
                {
                    question: "If you increase the temperature of the cold object to match the hot object (e.g., both at 70°C), what will happen to the heat flow?",
                    options: [
                        "Heat flow will stop (thermal equilibrium).",
                        "Heat flow will increase.",
                        "Heat flow will reverse.",
                        "Heat flow will continue at the same rate."
                    ],
                    correctAnswer: "Heat flow will stop (thermal equilibrium).",
                    explanation: "Heat flows due to a temperature difference. When temperatures are equal, there is no net flow of heat, and the objects are in thermal equilibrium."
                }
            ];

            function renderQuiz() {
                quizQuestions.forEach((q, index) => {
                    const quizCard = document.createElement('div');
                    quizCard.classList.add('quiz-card');
                    quizCard.innerHTML = `
                        <div class="quiz-question">${index + 1}. ${q.question}</div>
                        <ul class="quiz-options">
                            ${q.options.map((option, optIndex) => `
                                <li class="quiz-option" data-q="${index}" data-opt="${optIndex}">
                                    <span>${option}</span>
                                    <span class="feedback"></span>
                                </li>
                            `).join('')}
                        </ul>
                        <div class="quiz-explanation" style="display: none;"></div>
                    `;
                    quizContainer.appendChild(quizCard);
                });

                const quizOptions = quizContainer.querySelectorAll('.quiz-option');
                quizOptions.forEach(option => {
                    option.addEventListener('click', handleQuizAnswer);
                });
            }

            function handleQuizAnswer(event) {
                const clickedOption = event.currentTarget;
                if (clickedOption.classList.contains('answered')) return; // Prevent re-answering

                const questionIndex = parseInt(clickedOption.dataset.q);
                const optionIndex = parseInt(clickedOption.dataset.opt);
                const currentQuestion = quizQuestions[questionIndex];

                // Disable other options for this question
                const optionsForQuestion = clickedOption.parentNode.querySelectorAll('.quiz-option');
                optionsForQuestion.forEach(opt => {
                    opt.classList.add('answered'); // Mark as answered
                    opt.removeEventListener('click', handleQuizAnswer); // Remove listener
                    if (opt !== clickedOption) {
                        opt.style.opacity = '0.5'; // Dim other options
                    }
                });

                const isCorrect = currentQuestion.options[optionIndex] === currentQuestion.correctAnswer;

                if (isCorrect) {
                    clickedOption.classList.add('correct');
                    clickedOption.querySelector('.feedback').textContent = '✅';
                } else {
                    clickedOption.classList.add('incorrect');
                    clickedOption.querySelector('.feedback').textContent = '❌';

                    // Highlight the correct answer if an incorrect one was chosen
                    optionsForQuestion.forEach((opt, idx) => {
                        if (currentQuestion.options[idx] === currentQuestion.correctAnswer) {
                            opt.classList.add('correct');
                            opt.querySelector('.feedback').textContent = '✅';
                        }
                    });
                }

                // Show explanation
                const explanationDiv = clickedOption.closest('.quiz-card').querySelector('.quiz-explanation');
                explanationDiv.textContent = currentQuestion.explanation;
                explanationDiv.style.display = 'block';
            }

            // --- Initialization ---
            function initSimulation() {
                // Set initial state from sliders
                state.hotTemp = parseInt(hotTempSlider.value);
                state.coldTemp = parseInt(coldTempSlider.value);

                // Set initial particle positions
                generateParticles(Math.round(state.hotTemp * state.particleDensityFactor), state.hotTemp, hotRect);
                generateParticles(Math.round(state.coldTemp * state.particleDensityFactor), state.coldTemp, coldRect);

                updateSimulation(); // Initial render
                renderQuiz(); // Render quiz questions

                // Start animation loop
                setInterval(updateSimulation, 100); // Update every 100ms
            }

            initSimulation();
        });
    </script>
</body>
</html>
```