```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flow of Heat Simulator</title>
  <style>
    :root {
      --bg: #f7fafc;
      --card: #ffffff;
      --accent: #3b82f6;
      --accent-light: #93c5fd;
      --text-primary: #1f2937;
      --text-secondary: #6b7280;
      --success: #10b981;
      --error: #ef4444;
      --running: #f59e0b;
      --hot: #ef4444;
      --cold: #3b82f6;
      --neutral: #6b7280;
      --flow-indicator: #f59e0b;
      --particle-color: #f59e0b;
      --text-light: #ffffff;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      padding: 1rem;
      line-height: 1.6;
    }

    .container {
      max-width: 720px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      padding: 1.5rem;
      background: var(--card);
      border-radius: 12px;
      margin-bottom: 1rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.06);
    }

    h1 {
      font-size: 1.8rem;
      color: var(--accent);
      margin-bottom: 0.5rem;
    }

    .card {
      background: var(--card);
      padding: 1rem;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.06);
      margin-bottom: 1rem;
    }

    /* SVG Canvas */
    #simCanvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      background: #fdfdfd;
      border: 1px solid #e5e7eb;
    }

    /* Button Styles */
    .button-group {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .btn {
      flex: 1;
      min-height: 44px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
      transform: translateY(-1px);
    }

    .btn-primary:disabled {
      background: var(--running);
      cursor: not-allowed;
    }

    .btn-secondary {
      background: #e5e7eb;
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: #d1d5db;
    }

    /* Slider Controls */
    .control-group {
      margin-bottom: 1rem;
    }

    .control-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }

    .control-label {
      font-weight: 600;
      color: var(--text-primary);
    }

    .control-value {
      font-weight: 600;
      color: var(--accent);
      background: var(--accent-light);
      padding: 2px 8px;
      border-radius: 4px;
    }

    input[type="range"] {
      width: 100%;
      height: 8px;
      -webkit-appearance: none;
      appearance: none;
      background: #d1d5db;
      border-radius: 4px;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    /* Status Display */
    .status {
      text-align: center;
      padding: 0.75rem;
      border-radius: 8px;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .status.ready { background: #e0f2fe; color: #0369a1; }
    .status.running { background: #fef3c7; color: #92400e; }
    .status.complete { background: #d1fae5; color: #065f46; }

    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.75rem;
      margin-top: 1rem;
    }

    .stat-card {
      padding: 0.75rem;
      background: #f9fafb;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }

    .stat-label {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 0.25rem;
    }

    .stat-value {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--accent);
    }

    /* SVG specific styles */
    .object {
      transition: fill 0.2s ease-out;
    }
    .particle {
      transition: fill 0.1s ease-out;
    }
    .flow-arrow {
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }
    .pulsing-arrow {
      animation: pulse 1.5s infinite ease-in-out alternate;
    }
    @keyframes pulse {
      from { opacity: 0.7; transform: scale(1); }
      to { opacity: 1; transform: scale(1.1); }
    }
  </style>
</head>
<body>

<div class="container">
  <header>
    <h1>Flow of Heat</h1>
    <p>Heat energy always moves from hotter objects/regions to colder objects/regions, driven by temperature differences, until thermal equilibrium is reached.</p>
  </header>

  <!-- Visualization Card -->
  <div class="card">
    <h2>Visual Simulation</h2>
    <svg id="simCanvas" viewBox="0 0 500 350">
      <!-- Background -->
      <rect width="100%" height="100%" fill="#e5e7eb" rx="8"/>

      <!-- Left Object (Hotter) -->
      <rect id="objectLeft" x="100" y="150" width="100" height="50" rx="5" class="object" fill="var(--hot)"></rect>
      <text x="100" y="140" font-size="10" fill="var(--text-light)" text-anchor="start">Hot Object</text>
      <text id="tempLeftDisplay" x="100" y="195" font-size="12" fill="var(--text-light)" text-anchor="start">Temp: 80°C</text>

      <!-- Right Object (Colder) -->
      <rect id="objectRight" x="300" y="150" width="100" height="50" rx="5" class="object" fill="var(--cold)"></rect>
      <text x="300" y="140" font-size="10" fill="var(--text-light)" text-anchor="start">Cold Object</text>
      <text id="tempRightDisplay" x="300" y="195" font-size="12" fill="var(--text-light)" text-anchor="start">Temp: 20°C</text>

      <!-- Flow Arrow -->
      <path id="flowArrow" class="flow-arrow" 
            d="M 250 175 L 260 165 L 250 155 L 255 175 L 250 195 Z" 
            fill="var(--flow-indicator)">
      </path>

      <!-- Particles will be dynamically added here -->
    </svg>
  </div>

  <!-- Controls Card -->
  <div class="card">
    <h2>Controls</h2>
    
    <div class="status ready" id="statusDisplay">Ready to Start</div>

    <div class="button-group">
      <button id="startBtn" class="btn btn-primary">▶ Start Animation</button>
      <button id="resetBtn" class="btn btn-secondary">↺ Reset</button>
    </div>

    <div class="control-group">
      <div class="control-header">
        <span class="control-label">Temperature Difference (°C)</span>
        <span class="control-value" id="slider1Val">60°C</span>
      </div>
      <input type="range" id="slider1" min="0" max="100" value="60" step="1">
    </div>

    <div class="control-group">
      <div class="control-header">
        <span class="control-label">Object Mass/Capacity</span>
        <span class="control-value" id="slider2Val">1.0x</span>
      </div>
      <input type="range" id="slider2" min="0.5" max="2.0" value="1.0" step="0.1">
    </div>

    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Heat Flow Rate</div>
        <div class="stat-value" id="stat1">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Equilibrium Time</div>
        <div class="stat-value" id="stat2">N/A</div>
      </div>
    </div>
  </div>

  <!-- Educational Content -->
  <div class="card">
    <h2>Key Concepts</h2>
    <p>This simulation demonstrates the fundamental principle of the **flow of heat**. Heat energy naturally moves from regions of higher temperature to regions of lower temperature. This movement continues until both regions reach the same temperature, a state known as **thermal equilibrium**. The simulation visually shows particles representing thermal energy streaming from the hotter object (left) to the colder object (right), causing both objects to gradually change color towards a neutral shade, indicating an equalized temperature. The rate of flow and time to reach equilibrium are influenced by the temperature difference and the heat capacity (mass/size) of the objects.</p>
  </div>
</div>

<script>
  // === CONSTANTS ===
  const SVG_NS = "http://www.w3.org/2000/svg";
  const CANVAS_WIDTH = 500;
  const CANVAS_HEIGHT = 350;

  // Initial Object Properties
  const INITIAL_HOT_TEMP = 80;
  const INITIAL_COLD_TEMP = 20;
  const MAX_TEMP = 100;
  const MIN_TEMP = 0;

  // Particle properties
  const PARTICLE_RADIUS = 2;
  const BASE_PARTICLE_COUNT_LEFT = 100;
  const BASE_PARTICLE_COUNT_RIGHT = 50;
  const HOT_JIGGLE_SPEED = 5;
  const COLD_JIGGLE_SPEED = 1;
  const HOT_JIGGLE_RANGE = 3;
  const COLD_JIGGLE_RANGE = 1;

  // Animation speeds (frames per second equivalent for these values)
  const BASE_FLOW_SPEED_PX_PER_FRAME = 0.8;
  const BASE_TEMP_CHANGE_PER_FRAME = 0.01;
  const BASE_PARTICLE_ADD_INTERVAL = 100; // ms
  const BASE_PARTICLE_REMOVE_INTERVAL = 200; // ms

  // === STATE MANAGEMENT ===
  let animationState = {
    isRunning: false,
    animationId: null,
    startTime: 0,
    currentTempLeft: INITIAL_HOT_TEMP,
    currentTempRight: INITIAL_COLD_TEMP,
    particles: [],
    objects: {},
    slider1Val: 60, // Temp Difference
    slider2Val: 1.0, // Mass/Capacity
    equilibriumReached: false,
    equilibriumTime: 0,
    lastParticleAdd: 0,
    lastParticleRemove: 0
  };

  // === DOM ELEMENTS ===
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const slider1 = document.getElementById('slider1');
  const slider2 = document.getElementById('slider2');
  const statusDisplay = document.getElementById('statusDisplay');
  const simCanvas = document.getElementById('simCanvas');
  const tempLeftDisplay = document.getElementById('tempLeftDisplay');
  const tempRightDisplay = document.getElementById('tempRightDisplay');
  const stat1Display = document.getElementById('stat1'); // Heat Flow Rate
  const stat2Display = document.getElementById('stat2'); // Equilibrium Time
  const flowArrow = document.getElementById('flowArrow');

  // === HELPER FUNCTIONS ===
  function getRandom(min, max) {
    return Math.random() * (max - min) + min;
  }

  function interpolateColor(temp) {
    // Interpolate between HOT (#ef4444), NEUTRAL (#6b7280), COLD (#3b82f6)
    const hotColor = [239, 68, 68]; // red
    const neutralColor = [107, 114, 128]; // gray
    const coldColor = [59, 130, 212]; // blue

    let r, g, b;
    if (temp >= 50) {
      // Interpolate from hot to neutral
      const ratio = (temp - 50) / 50;
      r = Math.round(hotColor[0] * (1 - ratio) + neutralColor[0] * ratio);
      g = Math.round(hotColor[1] * (1 - ratio) + neutralColor[1] * ratio);
      b = Math.round(hotColor[2] * (1 - ratio) + neutralColor[2] * ratio);
    } else {
      // Interpolate from neutral to cold
      const ratio = (50 - temp) / 50;
      r = Math.round(neutralColor[0] * (1 - ratio) + coldColor[0] * ratio);
      g = Math.round(neutralColor[1] * (1 - ratio) + coldColor[1] * ratio);
      b = Math.round(neutralColor[2] * (1 - ratio) + coldColor[2] * ratio);
    }
    return `rgb(${r}, ${g}, ${b})`;
  }

  function updateObjectProperties() {
    const tempDiff = animationState.slider1Val;
    const massCapacity = animationState.slider2Val;

    // Adjust initial temperatures based on difference
    animationState.currentTempLeft = Math.min(MAX_TEMP, 50 + tempDiff / 2);
    animationState.currentTempRight = Math.max(MIN_TEMP, 50 - tempDiff / 2);
    
    const objectWidth = 100 * massCapacity;
    const objectHeight = 50 * massCapacity;
    const objectLeftX = 100;
    const objectRightX = CANVAS_WIDTH - objectWidth - 100;
    const objectY = (CANVAS_HEIGHT - objectHeight) / 2;

    animationState.objects.left = {
      x: objectLeftX, y: objectY, width: objectWidth, height: objectHeight,
      initialTemp: animationState.currentTempLeft,
      initialParticleCount: Math.round(BASE_PARTICLE_COUNT_LEFT * massCapacity),
      color: interpolateColor(animationState.currentTempLeft)
    };
    animationState.objects.right = {
      x: objectRightX, y: objectY, width: objectWidth, height: objectHeight,
      initialTemp: animationState.currentTempRight,
      initialParticleCount: Math.round(BASE_PARTICLE_COUNT_RIGHT * massCapacity),
      color: interpolateColor(animationState.currentTempRight)
    };

    // Update SVG elements
    const objLeftSvg = document.getElementById('objectLeft');
    objLeftSvg.setAttribute('x', animationState.objects.left.x);
    objLeftSvg.setAttribute('y', animationState.objects.left.y);
    objLeftSvg.setAttribute('width', animationState.objects.left.width);
    objLeftSvg.setAttribute('height', animationState.objects.left.height);
    objLeftSvg.setAttribute('fill', animationState.objects.left.color);

    const objRightSvg = document.getElementById('objectRight');
    objRightSvg.setAttribute('x', animationState.objects.right.x);
    objRightSvg.setAttribute('y', animationState.objects.right.y);
    objRightSvg.setAttribute('width', animationState.objects.right.width);
    objRightSvg.setAttribute('height', animationState.objects.right.height);
    objRightSvg.setAttribute('fill', animationState.objects.right.color);

    // Update text positions based on object size
    document.querySelector('#objectLeft text').setAttribute('x', animationState.objects.left.x);
    document.querySelector('#objectLeft text').setAttribute('y', animationState.objects.left.y - 5);
    document.getElementById('tempLeftDisplay').setAttribute('x', animationState.objects.left.x);
    document.getElementById('tempLeftDisplay').setAttribute('y', animationState.objects.left.y + animationState.objects.left.height + 15);

    document.querySelector('#objectRight text').setAttribute('x', animationState.objects.right.x + animationState.objects.right.width);
    document.querySelector('#objectRight text').setAttribute('y', animationState.objects.right.y - 5);
    document.getElementById('tempRightDisplay').setAttribute('x', animationState.objects.right.x + animationState.objects.right.width - document.getElementById('tempRightDisplay').getBBox().width); // Adjust for text width
    document.getElementById('tempRightDisplay').setAttribute('y', animationState.objects.right.y + animationState.objects.right.height + 15);
  }

  function resetParticles() {
    animationState.particles = [];
    // Create initial particles
    for (let i = 0; i < animationState.objects.left.initialParticleCount; i++) {
      animationState.particles.push({
        id: `p_${i}_l`,
        x: getRandom(animationState.objects.left.x, animationState.objects.left.x + animationState.objects.left.width),
        y: getRandom(animationState.objects.left.y, animationState.objects.left.y + animationState.objects.left.height),
        vx: 0, vy: 0,
        color: 'var(--particle-color)',
        originalObject: 'left',
        speed: HOT_JIGGLE_SPEED,
        range: HOT_JIGGLE_RANGE
      });
    }
    for (let i = 0; i < animationState.objects.right.initialParticleCount; i++) {
      animationState.particles.push({
        id: `p_${i}_r`,
        x: getRandom(animationState.objects.right.x, animationState.objects.right.x + animationState.objects.right.width),
        y: getRandom(animationState.objects.right.y, animationState.objects.right.y + animationState.objects.right.height),
        vx: 0, vy: 0,
        color: 'var(--particle-color)',
        originalObject: 'right',
        speed: COLD_JIGGLE_SPEED,
        range: COLD_JIGGLE_RANGE
      });
    }
    updateParticleElements();
  }

  function updateParticleElements() {
    const particleContainer = document.getElementById('particleContainer');
    if (!particleContainer) {
      const container = document.createElementNS(SVG_NS, 'g');
      container.id = 'particleContainer';
      simCanvas.appendChild(container);
    }
    
    const currentParticleElements = simCanvas.querySelectorAll('.particle-svg');
    currentParticleElements.forEach(el => el.remove());

    const container = document.getElementById('particleContainer');
    animationState.particles.forEach(p => {
      const circle = document.createElementNS(SVG_NS, 'circle');
      circle.setAttribute('cx', p.x);
      circle.setAttribute('cy', p.y);
      circle.setAttribute('r', PARTICLE_RADIUS);
      circle.setAttribute('fill', p.color);
      circle.setAttribute('class', 'particle-svg particle');
      container.appendChild(circle);
    });
  }

  function updateSimulation() {
    updateObjectProperties();
    if (!animationState.isRunning) { // Only reset particles if not running
      resetParticles();
    }
    updateUI();
  }

  function updateUI() {
    const tempLeft = animationState.currentTempLeft;
    const tempRight = animationState.currentTempRight;
    const tempDiff = animationState.slider1Val;
    const massCapacity = animationState.slider2Val;

    tempLeftDisplay.textContent = `Temp: ${tempLeft.toFixed(1)}°C`;
    tempRightDisplay.textContent = `Temp: ${tempRight.toFixed(1)}°C`;
    
    const objLeftSvg = document.getElementById('objectLeft');
    objLeftSvg.setAttribute('fill', interpolateColor(tempLeft));
    const objRightSvg = document.getElementById('objectRight');
    objRightSvg.setAttribute('fill', interpolateColor(tempRight));

    slider1Val.textContent = `${tempDiff}°C`;
    slider2Val.textContent = `${massCapacity}x`;

    if (animationState.equilibriumReached) {
      stat2Display.textContent = `${animationState.equilibriumTime.toFixed(1)}s`;
    } else {
      stat2Display.textContent = 'N/A';
    }

    // Calculate and display Heat Flow Rate (simplified metric)
    const effectiveTempDiff = Math.abs(tempLeft - tempRight);
    const flowMagnitude = (effectiveTempDiff / 100) * (animationState.objects.left.width / 100); // Simple proxy
    stat1Display.textContent = `${flowMagnitude.toFixed(2)}`;
  }

  // === ANIMATION LOGIC ===
  function startAnimation() {
    if (animationState.isRunning) return;

    animationState.isRunning = true;
    animationState.startTime = Date.now();
    animationState.equilibriumReached = false;
    animationState.equilibriumTime = 0;
    animationState.lastParticleAdd = Date.now();
    animationState.lastParticleRemove = Date.now();

    startBtn.disabled = true;
    startBtn.textContent = '⏸ Running...';
    statusDisplay.textContent = 'Animation Running';
    statusDisplay.className = 'status running';
    flowArrow.style.opacity = '1';
    flowArrow.classList.add('pulsing-arrow');

    animate();
  }

  function animate() {
    if (!animationState.isRunning) return;

    const currentTime = Date.now();
    const elapsedTime = currentTime - animationState.startTime;

    // --- Calculate dynamics based on sliders ---
    const tempDiffSlider = animationState.slider1Val;
    const massCapacity = animationState.slider2Val;

    // Adjust speeds and rates based on sliders
    const flowSpeedMultiplier = 1 + (tempDiffSlider / 100) * 1.5; // Faster flow with higher temp diff
    const tempChangeRateMultiplier = 1 / massCapacity; // Slower temp change with higher capacity
    const particleAddInterval = BASE_PARTICLE_ADD_INTERVAL * massCapacity;
    const particleRemoveInterval = BASE_PARTICLE_REMOVE_INTERVAL * massCapacity;

    // --- Update Temperatures ---
    const currentTempLeft = animationState.currentTempLeft;
    const currentTempRight = animationState.currentTempRight;
    const avgTemp = (currentTempLeft + currentTempRight) / 2;
    const tempDifference = currentTempLeft - currentTempRight;

    const baseTempChange = BASE_TEMP_CHANGE_PER_FRAME * tempChangeRateMultiplier;
    
    if (Math.abs(tempDifference) > 1) { // Only change if significant difference
      animationState.currentTempLeft -= baseTempChange * (tempDifference / 50); // More change for larger diff
      animationState.currentTempRight += baseTempChange * (tempDifference / 50);
      
      // Clamp temperatures
      animationState.currentTempLeft = Math.max(MIN_TEMP, Math.min(MAX_TEMP, animationState.currentTempLeft));
      animationState.currentTempRight = Math.max(MIN_TEMP, Math.min(MAX_TEMP, animationState.currentTempRight));
    }

    // --- Update Particle Positions and Add/Remove ---
    const objLeft = animationState.objects.left;
    const objRight = animationState.objects.right;

    // Add new particles
    if (currentTime - animationState.lastParticleAdd > particleAddInterval) {
        if (animationState.particles.length < objLeft.initialParticleCount + objRight.initialParticleCount * 0.5) { // Limit total particles slightly for performance
            animationState.particles.push({
                id: `p_${Date.now()}_add`,
                x: getRandom(objLeft.x, objLeft.x + objLeft.width),
                y: getRandom(objLeft.y, objLeft.y + objLeft.height),
                vx: 0, vy: 0,
                color: 'var(--particle-color)',
                originalObject: 'left',
                speed: HOT_JIGGLE_SPEED,
                range: HOT_JIGGLE_RANGE
            });
            animationState.lastParticleAdd = currentTime;
        }
    }

    const particlesToRemove = [];
    animationState.particles.forEach((p, index) => {
        // --- Jiggle Motion ---
        const jiggleX = getRandom(-p.range, p.range);
        const jiggleY = getRandom(-p.range, p.range);
        p.vx = jiggleX * (p.speed / 10); // Scale jiggle based on speed
        p.vy = jiggleY * (p.speed / 10);

        // --- Flow Motion ---
        const particleTemp = (p.originalObject === 'left') ? animationState.currentTempLeft : animationState.currentTempRight;
        const targetTemp = (p.originalObject === 'left') ? animationState.currentTempRight : animationState.currentTempLeft;
        const tempDifferenceForParticle = particleTemp - targetTemp;

        let flowVx = 0;
        let flowVy = 0;

        if (p.originalObject === 'left' && tempDifferenceForParticle > 1) { // Flow from left to right
            const flowFactor = Math.max(0, tempDifferenceForParticle / 100); // 0 to 1 based on temp diff
            flowVx = BASE_FLOW_SPEED_PX_PER_FRAME * flowSpeedMultiplier * flowFactor;
        } else if (p.originalObject === 'right' && tempDifferenceForParticle < -1) { // Flow from right to left (less common but possible if cold becomes hotter)
             const flowFactor = Math.max(0, Math.abs(tempDifferenceForParticle) / 100); // 0 to 1 based on temp diff
            flowVx = -BASE_FLOW_SPEED_PX_PER_FRAME * flowSpeedMultiplier * flowFactor;
        }

        p.x += p.vx + flowVx;
        p.y += p.vy + flowVy;

        // --- Boundary Checks and Object Transfer ---
        const objLeftBounds = { left: objLeft.x, right: objLeft.x + objLeft.width, top: objLeft.y, bottom: objLeft.y + objLeft.height };
        const objRightBounds = { left: objRight.x, right: objRight.x + objRight.width, top: objRight.y, bottom: objRight.y + objRight.height };

        if (p.originalObject === 'left') {
            if (p.x > objLeftBounds.right || p.y < objLeftBounds.top || p.y > objLeftBounds.bottom) { // Particle leaves left object
                if (p.x > objRightBounds.left && p.x < objRightBounds.right && p.y > objRightBounds.top && p.y < objRightBounds.bottom) {
                    // Successfully entered right object
                    p.originalObject = 'right';
                    p.speed = COLD_JIGGLE_SPEED;
                    p.range = COLD_JIGGLE_RANGE;
                    // Remove particles that leave left boundary but don't enter right (e.g., fall off bottom)
                } else if (p.x > objLeftBounds.right + 10) { // If it's far outside, remove it
                   particlesToRemove.push(index);
                }
            }
        } else if (p.originalObject === 'right') {
            if (p.x < objRightBounds.left || p.y < objRightBounds.top || p.y > objRightBounds.bottom) { // Particle leaves right object
                if (p.x > objLeftBounds.left && p.x < objLeftBounds.right && p.y > objLeftBounds.top && p.y < objLeftBounds.bottom) {
                    // Successfully entered left object (less common flow)
                    p.originalObject = 'left';
                    p.speed = HOT_JIGGLE_SPEED;
                    p.range = HOT_JIGGLE_RANGE;
                } else if (p.x < objRightBounds.left - 10) { // If it's far outside, remove it
                   particlesToRemove.push(index);
                }
            }
        }
    });
    
    // Remove marked particles
    particlesToRemove.sort((a, b) => b - a).forEach(index => animationState.particles.splice(index, 1));


    // --- Check for Equilibrium ---
    const tempDifference = Math.abs(animationState.currentTempLeft - animationState.currentTempRight);
    if (tempDifference < 1.5 && !animationState.equilibriumReached) { // Tolerance for equilibrium
      animationState.equilibriumReached = true;
      animationState.equilibriumTime = elapsedTime / 1000; // Convert ms to seconds
      statusDisplay.textContent = 'Equilibrium Reached!';
      statusDisplay.className = 'status complete';
      startBtn.disabled = false;
      startBtn.textContent = '▶ Start Animation';
      flowArrow.style.opacity = '0';
      flowArrow.classList.remove('pulsing-arrow');
      animationState.isRunning = false; // Stop animation automatically
    }

    // --- Update UI ---
    updateUI();
    updateParticleElements();

    // Continue animation
    if (animationState.isRunning) {
      animationState.animationId = requestAnimationFrame(animate);
    }
  }

  function resetSimulation() {
    // Stop animation
    animationState.isRunning = false;
    if (animationState.animationId) {
      cancelAnimationFrame(animationState.animationId);
      animationState.animationId = null;
    }
    
    animationState.startTime = 0;
    animationState.equilibriumReached = false;
    animationState.equilibriumTime = 0;
    animationState.currentTempLeft = INITIAL_HOT_TEMP;
    animationState.currentTempRight = INITIAL_COLD_TEMP;
    animationState.lastParticleAdd = 0;
    animationState.lastParticleRemove = 0;

    // Reset UI
    startBtn.disabled = false;
    startBtn.textContent = '▶ Start Animation';
    statusDisplay.textContent = 'Ready to Start';
    statusDisplay.className = 'status ready';
    flowArrow.style.opacity = '0';
    flowArrow.classList.remove('pulsing-arrow');

    // Reset sliders to their current values
    slider1.value = animationState.slider1Val;
    slider2.value = animationState.slider2Val;

    // Reset visuals to initial state
    updateSimulation();
  }

  // === SLIDER HANDLERS ===
  function handleSlider1Change(e) {
    animationState.slider1Val = parseFloat(e.target.value);
    updateUI();
    if (!animationState.isRunning) {
      updateSimulation(); // Update visuals if not running
    }
  }

  function handleSlider2Change(e) {
    animationState.slider2Val = parseFloat(e.target.value);
    updateUI();
    if (!animationState.isRunning) {
      updateSimulation(); // Update visuals if not running
    }
  }

  // === INITIALIZATION ===
  function initSimulation() {
    // Button event listeners
    startBtn.addEventListener('click', startAnimation);
    resetBtn.addEventListener('click', resetSimulation);
    
    // Slider event listeners
    slider1.addEventListener('input', handleSlider1Change);
    slider2.addEventListener('input', handleSlider2Change);
    
    // Initial state setup
    animationState.slider1Val = parseFloat(slider1.value);
    animationState.slider2Val = parseFloat(slider2.value);
    
    updateSimulation(); // Initial render and particle setup
  }

  // === START ON LOAD ===
  document.addEventListener('DOMContentLoaded', initSimulation);
</script>

</body>
</html>
```